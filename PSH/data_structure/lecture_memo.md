###기타 메모 ###
--- 
-.assert() : 여기에다가 어떤 상황이 에러다 조건을 주는 것  

### 찾기 ###
---
-.이중포인터, amalloc, 링크드 리스트  
-.1회차에 정리했던 내용 복습  
-.ctag도 이왕 한김에 정리하자  
-.vim끼리 복사하는 방법 찾아보기  
-.c코드 짠거 gdb로 디버깅하면서 찾아보자  

### 숙제 관련 ###
---
-.재귀호출을 사용하여 queue 관련 숙제 진행  
-.queue insert 관련 내용 구현할 때 재귀호출이 필요할 수 있는데  
-.도전 과제로서 진행해보기  
-.pdf 파일 참고  
-.애니매이션으로 이해하고 머릿속에 그려져야 함  

### 질문 ###
--- 
-.nr_print_tree 에서 stack 써서 이중포인터 처리하는 이유 다시 한번 질문하기  
=> push에서 만들어진 stack data에 복귀 주소가 전부 저장되어 있어서 이전 pop 데이터로 갈 방법 찾을 수 있음

### Markdonw 관련 ###
--- 
-.문장 맨 마지막에 스페이스 2번 : 줄 바꿈  
-.터미널 탭벼환 : Alt 1, 2   
-.git config --global credential.helper cache : 토큰 재 입력 필요 없게 하는거  
-."MarkdownPreview" vim 명령기에 입력하면 실시간으로 볼 수 있음  

### GDB 관련 ###
---
gcc -g -O0 function_asm.c -o fasm : -g 주고 컴파일  
gdb fasm  
shell clear :  gdb 창 초기화  
q : gdb 종료  
b main : breakpoint  
r:run  
disas  
b *0x000055555555465d push 쪽에다가 break를 가리킨다.  

rbp            0x5555555546b0	0x5555555546b0 <__libc_csu_init>  
rsp            0x7fffffffdd78	0x7fffffffdd78  

l : 현재 진행하고 있는 코드 리스팅  
실제 주소가 안나오는 경우가 있음  
l mult : mult 함수 가리킴  
s:step into (c언어 레벨 벼로)  
변수  특정 데이터 타입을 저장하는 메모리 공간  
si : step into ~ 한칸 이동 (인스트럭션 레벨 별로)  
push : stack 에 밀어넣음  
rbp: rbp레지스터에 들어있는 값  
info registers : 내 PC의 레지스터 정보  
rax,rbx, bl, al, eax ... 인텔 계열  
al , bl : a, b 로 시작하는 인텔 계열 레지스터중 하위 바이트 (8byte)  
csic vs risc : 다시 보기 메모리 투 메모리는 인텔만 되고 arm은 메모리 투 레지스터 갔다가 레지스터에서 메모리에 다시 저장하는 방식....  
ax  : 함수의 리턴값이 저장되는 레지스터(ax 계열들) r은 비트 수니까 상관x  
bp : base pointer 출발점 기준점 역할  
sp : stack pointer 스텍 최상위 나타냄 , 스택은 아래로 쌓음(heap은 위로 쌓음)  
ip : instruction pointer 다음에 실행할 프로그램의 주소값 포인팅  
eflags : 인터럽트 등의 flag 처리 제어 마스킹 등의 역할  
p/x $rsp : p 출력 /x 16진수로  뿌려라 $레지스터 값을 보겠다.  
ps -ef : 현재 프로그램에 돌고 있는 모든 프로세스 들  
x $rsp :  메모리 뿌려서 볼 수 있음  

펌웨어로 영상 못하는 이유는 메모리 순회 검색을 못하기 때문이다.  

mov : 복사 명령과 같다 c언어 num =3 의 등호 = 같은 역할$   
movl : 4byte 데이터 이용시킬 때 movl  

재귀함수는 동작하는 코드만 동일할뿐 새로 push pop 하는 것  
pop: 현재 stac의 최상의 의 값이 저장됨  
retq : pop rip랑 같은 의미  

l : 4바이트  
q: 8바이트  

n : step out   
ni : step out (instruction 단위)  
(gdb) x/c $rsp : 문자열로 register rsp의 메모리 확인 askii value같은 것을 확인  
imul : int mul   

-. bt : back trace로 call stack을 분석  
-. s : step into , n : step out (i를 제거하면 c 레벨에서 보는것  
-. tree 에서 재귀안쓰고 이중포인터를 쓰는 이유 공부 필요  
-. 이중포인터는 실제 제어 대상을 직접 건드리지 않고 외부에서 참조가 가능하다.  

### GDB 질문 ###
---
rax, rbp, rsp 는 CPU 레지스터이고 eax esi 등은 무엇? 
=> 같은 CPU 안의 레지스터인데 비트수에 따라 rax 가 64bit면 그 중에 32bit만 사용할 때 eax로 말하는것인가?
	info registers 보면 eax에 넣은값이 rax에 그대로 들어와 있는것을 확인할 수 있음
	왜 r로 안표현하고 e를 사용해서 했을까 굳이 크기가 r만큼이 아니어서?
가상메모리 개념 : 1기 github 참고
sub $0x10, %rsp : 0x10이라는 값은 어떻게 판단한걸까?
stack에 들어가는 게 뭐뭐 있는지 찾아보기 (지역변수, 등등)
esi, edi도 범용 레지스터 인가? 무슨 역할이지?
=> 일반저ㅏㄱ인 연상세너는 역할이 없다.
call 진행시 스택에 복귀 주소 저장하는데 이놈은 리틀엔디안 방식이던데 왜?
res 변수 메모리공간이 나중에 값을 입력할 때야 넣어준다.
l 명령의 정확한 사용법?
지금 명령어 가 C의 어디위치인지 보는 방법? l로 보는 것인가?
컴파일 최적화 시 어떻게 달라지는지도 확인필요
rdi 랑 edi 랑 다른 레지스터가 되는 건가? x로 볼 때 하나는 메모리로 인식해서 되고 하나는 안되는데? LEA할 때
=> rdi가 되고 edi가 안될것 같은데 rdi에 메모리 8byte로 구성되기 때문에 edi는 메모리 주소가 아니게 된다.
lea로 문자열을 임의의  가상 메모리 공간에 할당 받는 것 같다.
jumpq로 하면 4byte 어긋나는 것 같은데???

### AVL 트리 ###
---
-.재귀호출 끝나고 AVL tree는 해당 사항을 확인하는 과정이 있음  
-.AVL 트리의 삽입과 삭제는 이진 탐색 트리와 동일   
-.재귀 방법으로 먼저 해보고 (쉬움) 비재귀 방법으로 한번 해보기  
-.AVL 트리는 이진 탐색 트리에서 삽입/삭제 연산에, 이런 균형을 잡는 회전을 전 노드에 대해서 재귀적으로 수행하는 과정을 추가하는 트리입니다
-.balancing에서 어쩔수 없이 재귀가 되는 이유 분석 필요
-.트리 추가하면서 level 업데이트를 실시간 할 수 있는 가 봤는데 안되는 경우가 있었다 여러짱구 굴려도 안되서 순회/재귀 방법을 택해야 했다.
-.단방향 순회는 레벨 업데이트코드랑 삽입 코드랑 중복되어서 지저분해지고 하기 때문에 양방향으로 부모를 포인팅할 수 있게 하는 방법도 있음
-.재귀로 해도 구현이 가능함.
-.결론은 밸런싱으로 순회/재귀 가능하며 실시간 레벨 업데이트는 안된다

### Red Black Tree ###
--- 
-.avl tree 특성을 가지고 있으면서 색상을 가지고 있음.  
-.root node 검은색, 자식노트 빨간색
-.NIL Node는 하나만 만들어서 포인팅하게 할 것  
-.빨간색 끼리는 붙어 있을 수 없다.
-.좌우측 검정색 갯수는 같아야 한다.
-.왼쪽 혹은 오른쪽은 상태측의 높이 2배를 넘을 수 없다.


