프로젝트 하는것처럼 복잡하게 하지않았다

블루버드?
한분은 경력이 오래되었고 한명은 신입 3,4,5

난이도를 완전 생 초짜에 맞춰달라해서 공업수학할때는 디렉토리를 분리해놨는데
이거는 좀 뭉터거리로해놨다

왔다갔다 하는데 발생하는 어려움은 없을것 같고
파일1

이거를 한번 확인하고
실질적으로 뭘하는지 볼려면 이걸지워야한다
rm -rf file_test.txt

file1을 실행하면 file_test.txt 를 생성하게 된다.

open

fopen 과 같다 윈도우에서 썼던 fopen은 몇 단계를 거친다

// (프레그먼트 프레그멘테이션) (slab 최소메모리 할당)
// exit(1) 은 어디로 리턴되나요??
// ffmpeg 커널이 아닌 어플리케이션으로 만들어놓은 끝판왕
// QEMU

함수 몇 뎁스를 거친다
그런데 open은 다이렉트로 커널로 쏜다
이런 아이오 작업이많은 프로그램을 한다고 하면
어떤게 더 좋을까?
open이 더좋다
윈도우는  open이 안된다.
통합으로 소프트웨어를 짠다고하면
윈도우즈 api아시죠?? 아니요...

메모리 하이라키 구조에서 피라미드가 이렇게 있는데 맨최상위 레지스터가있는데
-레지스터
-캐쉬
-메모리
-아이오
파일 입출력이 왜 아이오냐면 -> 하드디스크에 적는다
메모리 하이라키 관점에서 보면 하드디스크는 용량이 크지만 속도가 느리다.
메모리 하이라키 속도는 빠른데 용량이 작다.
아이오를 빈번하게 요청하면 느리다

꼼수중 하나는 메모리에서 처리하고 있다가 정말 디스크에 써야하면 메모리에 정보를 밑으로 내린다.
블로킹 연산을 전부 이렇게 한다.

로우레벨 api로 코드가 작성이 된다.
삼성 반도체쪽에 --> 계산하는 장비들이 들어가는데
삼성 반도체쪽이 예전에 공정 수율을 높히겠다고
반도체 생산라인에서 넘어오는데이터를 가지고 딥러닝을해서 러닝커브를 올린다고 했는데
기존에 자바나 이런애들은 속도가 너무느려서
us 단위로 데이터가 넘어오면 로스되면 안되기 때문에
반도체 생산라인에서 넘어오는 시그널 데이터를 저장한다고 했을때
저장하는 개념이니까
메모리에 적던 디스크에적던 모니터링을 해야하니까
빨리빨리 처리해야하니까 fopen을 쓰면안된다.

//

파일명을 open에 적고 O_CREAT 생성하겠다. O_RDWR 리드 라이트 읽고쓰기 허용한다 0644 퍼미션

맨앞속성
d 디렉토리
- 

b nvram, nvme 흔히들 얘기하는 dram
	dynamic ram -> random access 가 가능하다
	c에서 어셈블러에서 볼때 함수 호출할때 콜할때 메모리 주소가 확뛰는데
	분기 for if switch call pointer 등등 모두 random access 때문에 가능하다
	순서쌍을 가지고있지않아도 되는애들
	데이터를 저장하는게 주목적인 애들
	저장된 데이터가 올바르게 들어가면 되는애들
	처리하는데 오래걸리면 좀 비워놓고 나머지 자리를 채워넣으면된다.
	블록디바이스들
	파일 io는 블록으로 들어가고 순서쌍은 보장되지않지만
	디스크 속도는 느리다.
	그렇기때문에 처리를 빨리할수있는애들은 먼저 넣고 늦는애들은 나중에넣자 하는애들은 전부b로 만들었다.
	
c 캐릭터 디바이스 (많이 사용하는 키보드 모니터 등등)
	왜 얘네들이 캐릭터냐면 실질적으로 게임할때
	뭐야 스킬 어떻게 쓸지 각을 잡고 싸우는데
	여러분들이 eqwr
	rqe 이런식으로 들어간다고했을때
	우린 계산해놓고 쓰는데
	키보드 눌리는 순서가 중요한데
	그런 문제가 발생하지않도록 서포트해주는 애들이 전부
	캐릭터 디바이스다
	순서쌍이 보장되야하는애들은 전부 캐릭터이다.
s 소켓 은 나타나진 않는다.
	네트워크 장치가 있으면 나타난다.
	소켓 장치를 b나 c로 통합시킨것 같다
	loopx쪽을 보면 전부 b로 되어있는데
	랜선 타고 나가는 쪽
	병렬 아이오로 동작하는데 이 애들이 시퀀스 넘버만 맞추면 되지 조합이될필요는 없다.
	네트워크는 순서쌍이 보존되어있지않아도 되서 b로 되어있다
	네트워크 그룹은 힘이쎄다
	시스코	CCNA, CCNP,CCIE
	
	스위치 MAC통신 (로컬통신)
	라우터 IP통신
	
	스위치 라우터 ... -> L4 스위치
	
	공유기는 맥통신도 서포트한다.
	인터넷으로 나가는것들은 ip통신이다.
	ip 공인ip 사설ip
	공인 ip를 써야지만 사람들과 통신이된다.
	NAT 통신 (사설 IP)
	NAT는 결국 게이트웨이에서 구현되어있어서 나간다.
	
	IPS, IDS (프로텍트 시스템)
	
	$ ifconfig
	

//

TRUNCATION 짜르따
기존에 있는걸 잘라버리고 덮어쓴다.

fd 숫자값이 나온다.

task_struct
	file_struct
		file **
		
fd의 index를 확인한다.
boolin

https://elixir.bootlin.com/linux/latest/source

rtos 얘기할때 pcb 프로세스 컨트롤 블록
task_struct 실제 프로세스나 스트럭트가 만드러지면 쓰여지는건 전부 얘다.
files_struct
정말 중요한 유닉스 개발자 켄 톰슨, 데니스 리치
이때 당시에 이사람들이 했던 얘기
c, 리눅스 모든 것은 파일이다.
리눅스의 핵심처럼
open file information
파일을 열겠다 -> 모니터 하드웨어 모든 프로세스들이 파일로 관리된다.
file __rct 포인터 배열이 들어가있다
포인터 배열은 파일 포인터가 들어있다.
배열 포인터는 배열인덱스 자체를 갖고있는 애들
가변 배열인데 fd_array -> 실제 파일 포인터를 관리한다.
눌러서 가보면 뭐가많이있는데
여기서 봐야할게 리눅스 fs.h를 들어가서 보면
이런게 나타나는데 file_operation *f_op;
라는게 있는데
그리고 지금 이 안을 들여다 보면 우리가 보고있는게 보인다.
linux fs.h
c로 구현하는 인터페이스
얘는 뭐가들어있냐
리눅스에는 다양한 종류의 파일 시스템이 지원됨.
리눅스의 대표격인 ext4,3,2
ntfs 비트리 (면접으로 나왔던적이있다) fat (연결리스트)
mtd 외에도 더 다양한게있다.
윈도우랑 리눅스랑 실시간으로 통신이된다.
리눅스가 ntfs를 해석할수있다.
ext4도 해석을 하는데
여기서 open을 쓴다면?
서로 해석하는 open이 다르다.

이폴더가 파일시스템이 뭔가
이게 뭔가 다알아야한다.
그렇게 알고 프로그래밍한다면?
file_operations 가 포인터로 되어있어서
시스템이 동작하면서 커널이 파일 시스템을 확인해서 바꿔끼워서 함수포인터를 바꿔끼운다.
상황에 따라서 우리가 원하는 open을 구동시킬수있다.
include/linux/fs.h

디펜던시 묶이는걸 방지하기 위해서 쓴다.
그케이스는 조금더 프로그래머블한 트릭을 쓸때 나온다.

인터페이스는 항상 추상화였는데
설명72시간 하면 사용자가집으로간다.
간단하게 얘기하는게 좋다.

함수포인터를 쓰는 근본적인 이유
세부사항을 가르키는

리눅스 커널 보면 10만줄 된다.
기왕 얘기가 나왔으니까 애자일 프로세스를 쓰는걸로 보면

파일 처리하는것에도 기능별로 쪼갤수가있는데 파일열기 읽기 쓰기 파일 권한 검사등등 -> 기능

기능을 만들고보면 다만들었다 짝짝 (회사)
만들때 당시에는 EXT4 였는데 얘는...
YAFFS
Ver1, Ver2...
기능단위가 아니라 비즈니스 로직으로 봐야한다.

파일시스템 이라는 비즈니스 로직으로 봐야한다.

파일시스템은 여러가진데?
여러가지를 커버하려면 어떻게 해야하지?

어디서든지 읽기 쓰기 등등은 들어가네?
이걸 어떻게 하지?
각각의 기능을 함수포인터로 묶을까?

이거를 비즈니스 로직 단위로 보면 공통기능들이 들어있는 부분을 빼자
이거를 담당하는 각각의 구현체는 들어가야하기때문에
작업량은 커진다.
나중에 유지보수 관점에서 볼때는 굉장히 편하다.

EXT4 -> (USB)FAT32 -> 

시나리오
1. USB(FAT32)
사실 커널 코드를 분석해야 하는데
USB(FAT32) 정보를 ext4로 복사

1. usb 연결시 외부 인터럽트 발생(usb)
1.1. 네고시에이션하면서 usb 데이터를 받아온다.
2. 인터럽트 처리 핸들러가 발생 s_op(super_block, super_operations - 디스크작업 저장매채), i_op(inode_operations - 디렉토리 관련), f_op(file_operation) 설정 (인터페이스) (결국 이 친구가 디바이스 드라이버)
3. 요거를 뭐하고할까 usb fop라고할게요 usb fop 가있고 disk fop 실제로 없긴한데 편하게 설명해야하니까
얘네들을 설정해놧을때 usb 내용을 읽어야할때 usb fop가 동작 open -> read 
4. disk fop 동작 open -> write
5. 그리고 각각 close
이런 동작이 자동으로 이루어진다.

이게 가능한건 인터페이스가 이루어져있기때문에
이게 다 동작...
이거는 모두 드라이버가 셋팅을 해준다.

임베디드 리눅스에서는 파일시스템에서 실제 단말기들은 제한된 환경이기 때문에
메모리도 한정적이고, 디스크 용량도 낮고 cpu스펙도 낮기 때문에
적은 리소스로 고효율을 내야하기때문에 구동에 반드시 필요한
파일시스템만 배치한거다.
그래서 그안에 fat이 없을수도있어서그렇다.
리눅스 이미지 만들때 추가하고 뺄수있다.

사실 에디샘이 실제하는 포팅은 이런것들을 처리할수있는 파일시스템 셋팅을 할줄알아야한다.
페타리눅스가 욕토로 되어있어서 fpga할때정말 힘들다.
fpga
욕토가 결국에는 이런 리눅스 이미지 빌드하는데 쉽게 해주는거다.

욕토 프로젝트가 이런걸 쉽게 가능하게 해주는거다.

빌드시스템을 욕토로 챱챱하게 해주는거다.

oop설계로 디펜던시 분리를 해놨는데
os에서는 그게 쉽지가않았는데
리눅스에서 빨리빨리하고싶은데 너무 어려워서 욕토를 만들었다.

욕토를 할려면 그안에 빌드시스템을 싹다알아야한다.
그런걸 통틀어서 조각조각 내놓은거라서
싹다알아야한다.

한귀로 듣고 한귀로 흘렸는데
욕토를 할려면 딥하게 많이 봐야한다.
리눅스 빌드시스템을 이해한다는건데 그걸 이해할려면좀 알아야한다.
요즘좀 느끼는거는 욕토를 우리가 fpga하는사람들은 좀 알아야한다.
다른사람들은 오히려 이 욕토는 제조사에서 알아서 하겠지...

얘에 이전 스택을 보면
include/linux/fdtable.h
fd = 할때 저게 바로 struct file __rcu * fd_array[NR_OPEN_DEFAULT];
fd값이 실제 출력이 숫자 3이상으로 나온다.

0이나 1이나 2가 나온다.(0입력 1출력 2에러)

시스템콜
리눅스하면서 학습하는 모든것들을 system call
 windows api
 
커널에다가 요청하는 작업

user -/-> kernel
   인터럽트

시스템콜은 유저영역에서 동작하는데
유저가 시스템콜은 요청하면 바로 커널로 들어간다
이말은 시스템콜은 인터럽트다.

유일한 소프트웨어 인터럽트
인터럽트는 하드웨어 시그널이 발생하면 발생하는건데
시스템콜이 떨어졌다 ->  하던거 멈추고 시스템콜을 처리하러간다. (sw인터럽트)
컨텍스트 스위칭이 일어난다

응답을 줄때 모든 커널의 모든부분을 까서 줄수없으니까 (구조체 전체를 줄수없으니까)
실제 인덱스 번호를 전달한다.
사용자가 이결과를보고 그다음 작업을 선택할수있도록 결과값을 준다 ( )

write 에는 fd가 들어가있다.
fd는 뭐냐
fd 는 똑같다.
커널이 배열을 미리 잡아놔서

*밀린거 공부

파일시스템의 핵심은 칠판에
설명한저거다.

네트워크 상황에서는  ex 반사파
20바이트가 나와야되는데 10바이트만 나올수도있다
그거를 처리할때 조건을 어떻게 넣어주냐에따라서 달라질수있다.

1번에 쓰고있을때, 모니터 (터미널 창에 연결된다)
write(1, buf, nread) -> printf의 정체

lseek (특정위치를 검색하며 찾는다) seeking하는 포인트 
커널코드와 같이본다
파일
fs.h -> f_pos 파일 포지션
파일의 현재 위치 => 현재 파일 포인터
파일안에 들여다보면 테스트  txt asdfasdf
시작과 끝 실질적으로 read할때 f_pos를 이동시키면서 한바이트씩읽는다.
다읽고 난다음에는 f_pos는 끝을 가르킨다. (eof)
f_pos(숫자값이에요) 12라는 위치를 갖고있을때
우리가 이 뒤에 뭔가를 이어서 붙히고 싶을때
이상태에서 write를 하면 끝 뒤에 붙는다.
이게아니라 맨앞으로 파일포인터를 땡기고 싶을때
그때 쓰는게 lseek(fd, (off_t)0, SEEK_SET);
SEEK_SET => 초기화로 봐도된다?
내가 원하는 위치로 파일포인터를 변화할수있다. (파싱할때쓴다)

디렉토리 순회하는 프로그램을 하나만들어볼꺼다
그냥 c로만들면 오래걸린다.
set과 end
SEEK_END를 보면 파일의 사이즈를 알수있다.
lseek(fd, (off_t)0, SEEK_END);
0에서부터 SEEK_END까지의 사이즈를 말한다.

newpos는 파일 사이즈가 된다.

seek_Set을 빼놓고 돌리면 그냥 돌수있다.
예를들어서 내가 잔뜩적어놨는데 필요가없을경우

과제를 말씀하셨으니까.
:%s/바꿀문자/변경된 문자/g
(전체)

파일에 있는 문자를 찾아서 저걸로 바꿔라
트렁크로는 바꾸지않는다.

1. strncmp 써서 문장 전체에서 검색해서 찾는다.
2. 한칸씩 이동하면서 틱틱틱틱틱
3. 위치값을 관리해서 붙일때 사용한다.
4. 통메인 상관 x

lseek가 파일포인터를 관리한다.
file5.c -> //lseek(fd, (off_t)0, SEEK_SET);

unistd -> unix standard
fcntl.h


man -s2 open
(시스템 프로그래머 메뉴얼)
(메뉴얼)
